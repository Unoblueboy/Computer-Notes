\subsection{Programming}
  \noindent
  \marginnote{4.1.1.1}[0cm]A data type determines what sort of datum is being stored and how it will be handled by the program. There are several built in data types common to many programming languages:
  \begin{itemize}
    \setlength\itemsep{0em}
    \item Integer: Any positive or negative whole number including zero.
      \subitem -2, -1, 0, 1, 2
    \item Real/Float: Any number with a decimal/fractional part.
      \subitem -1, $ -\frac{1}{2} $, 0, 0.543543, 1
    \item Boolean: True or False.
    \item Character: An individual character (alphanumerical or symbol).
      \subitem "a", "1", "\&"
    \item String: A sequence of characters.
      \subitem "Hello World"
    \item Date/Time: A date or time.
      \subitem 28.05.2016 12:39:40:056
    \item Pointer/ Reference: The location of a value in memory
	  \subitem pointer = 1023 would refer to the value in memory address 1023
    \item Records: A collection of items which be of different data types which are related.
      \subitem [ \{Name: "Nathan", age: 18\} ,\{Name: "Serena", age: 18\} ]
    \item Arrays: A collection of items of the same data type.
      \subitem [ "Ryan", "Helen", "Luke","Giorgia" ]
  \end{itemize}
  A user defined data type is a data type that is made of built-in data types (A data type that is provided within the programming language being used). In python you can write your own data types by writing type methods in C, or simply creating a class which does what you want. \\ \\
  \marginnote{4.1.1.2}[0cm]Within a program there is usually a combination of the following statement types:
  \begin{itemize}
    \setlength\itemsep{0em}
    \item Variable declaration: The process of defining a variable in terms of its data type and identifier (variable name).
    \item Constant declaration: The process of defining a constant in terms of its data type and identifier (constant name).
    \item Assignment: Giving a value to a variable or constant.
    \item Iteration: The principle of repeating processes.
    \item Selection: The principle of choosing what action to take based on certain criteria.
    \item Subroutine (AKA Procedure): A named block of code designed to carry out a specific task.
    \item Function: A subroutine which returns a value.
  \end{itemize}
  In python, all of the variables and constants are dynamically typed, meaning you don't have to worry about declaring a data type, as it is taken care of by the programming language. \\
  Within imperative programs the combining of the principles sequencing, iteration and selection are basic to all of them.\\
  Definite iteration is when a process repeats a set amount of time, for example:
  \begin{python}
for x in range(10):
	print("hi")\end{python}
  This would print \verb|hi| 10 times. Indefinite iteration is a process that repeats until a certain condition is met. This can be done in two ways, \textit{Method 1} with the condition at the beginning, and \textit{Method 2} with the condition at the end. The implications of these two methods is that \textit{Method 2} forces the loop to be done once, whereas the loop in method one may never be done. This can be shown using an example using both methods:
  \begin{multicols}{2}
    Method 1
    \begin{python}
x = 5
while x < 5:
	print(x)\end{python}

    \columnbreak
    Method 2
    \begin{python}
x = 5
while True:
	print(x)
	if not (x<5):
		break \end{python}

  \end{multicols}
  \noindent
  Method one results in nothing being printed as \verb|x| starts as \verb|5| so \verb|x<5| \verb|False|, so the loop never runs, so \verb|x| isn't printed. Method two results in \verb|5| being printed because \verb|True| is always \verb|True|, so the while loop runs printing \verb|x| which is equal to \verb|5|, the if statement then resolves to be true ( \verb|x<5| is \verb|False| so \verb|not x<5| is true) so the while loop \verb|break|s.\\
  Nesting is placing one set of instructions within another set of instructions, the most common use of nesting is nested selection (\verb|If...Elif...End|) and nested iteration(A for loop within a for loop).\\
  Within a program, the use of meaningful identifier names is encouraged due to the following reasons:
  \begin{itemize}
    \setlength\itemsep{0em}
    \item It's easier to debug (correct) code.
    \item Easier for others to understand when working on a large project.
    \item Easier to update the code.
  \end{itemize}
  \marginnote{4.1.1.3}[0cm]The basic arithmetic operations are:
  \begin{itemize}
    \setlength\itemsep{0em}
    \item Addition \verb|a + b|
      \subitem \verb|2 + 3 = 5|
    \item Subtraction \verb|a - b|
      \subitem \verb|2 - 3 = -1|
    \item Multiplication \verb|a * b|
      \subitem \verb|2 * 3 = 6|
    \item Real/Float Division \verb|a / b|
      \subitem \verb|2 / 3 = 0.6666666666|
    \item Integer Division: The result is the truncated integer of the result. \verb|a // b|
      \subitem \verb|17 // 3 = 5|
    \item Modulus \verb|a % b| (AKA remainder)
      \subitem \verb|17 % 3 = 2|
    \item Exponentiation ($a^b$) \verb|a ** b|
      \subitem \verb|2**3 = 8|
    \item rounding \verb|round(a)|
      \subitem \verb|round(0.6666666666)=1|, \verb|round(1.4352534234) = 1|
    \item truncation \verb|Math.trunc(a)|
      \subitem \verb|Math.trunc(0.6666666666)=0|, \verb|Math.trunc(1.4352534234) = 1|
  \end{itemize}
  \marginnote{4.1.1.4}[0cm]Relational operations are expressions that compare two values. Some common Relational Operations are:
  \begin{itemize}
    \setlength\itemsep{0em}
    \item equal to (\verb|==|)
    \item not equal to (\verb|!=|)
    \item less than (\verb|<|)
    \item greater than (\verb|>|)
    \item less than or equal to (\verb|<=|)
    \item greater than or equal to (\verb|>=|)
  \end{itemize}
  \marginnote{4.1.1.5}[0cm]Boolean operations are expressions that return the result \verb|True| or \verb|False|. Some common Boolean Operations are:
  \begin{itemize}
    \setlength\itemsep{0em}
    \item AND: Returns \verb|True| if both inputs are true.
    \item OR: Returns \verb|True| if either of its inputs are true.
    \item NOT: Negates (inverses) the input, \verb|True| $\to$ \verb|False|, \verb|False| $\to$ \verb|True|
    \item XOR: Returns \verb|True| if either of its inputs are true but not if both are true.
  \end{itemize}
  \marginnote{4.1.1.6}[0cm]A constant is an item of data whose value does not change whereas a variable is an item of data whose value could change while the program is being run. Named constants are useful because you can easily use them throughout the program, and don't have to worry about the initial value, also you can easily change it by changing the assignment and declaration of the constant.\\ \\
  \marginnote{4.1.1.7}[0cm]There are several ways to manipulate and convert strings from one data type to another. Some examples of string handling functions are:
  \begin{itemize}
    \setlength\itemsep{0em}
    \item Length: Returns the number of characters within a given string\\
    \verb|len("Hello World")=11|.
    \item Position: Returns the position of any character or string within another string \\
    \verb|"Hello World".index("World")=6|.
    \item Substring: Returns a string contained within another string.\\
    \verb|"Hello World"[0:5]="Hello"|.
    \item Concatenation: returns the result of Adding two strings together \\
    \verb|"Hello"+"World"="HelloWorld"|.
    \item Character$\to$Character Codes: Converts a character to a character code (a binary representation if a particular letter, number of special character).\\
    \verb|ord("A")=65|
    \item Character Codes$\to$Character: Converts a character code to a character.\\
    \verb|chr(65)="A"|
    \item String Conversion Operations
    \begin{itemize}
      \setlength\itemsep{0em}
      \item String to Integer:
        \subitem \verb|int("2")=2|
      \item String to Real/Float:
        \subitem \verb|float("2.432")=2.432|
      \item String to Date/Time:
        \subitem \verb|datetime.datetime.strptime('5 May 2016', '%d %b %Y')=|\\
\verb|                           datetime.datetime(2016, 5, 5, 0, 0)|
      \item Integer to String:
        \subitem \verb|str(2)="2"|
      \item Float to String:
        \subitem \verb|str(2.432)=2.432|
      \item Date/Time to String:
        \subitem \verb|time.strftime("%d/%m/%Y",time.localtime())="28/05/2016"|
    \end{itemize}
  \end{itemize}
  \marginnote{4.1.1.8}In python random number generator functions are all contained within the module \verb|random| and therefore requires us to import it using \verb|import random|. There are several functions within this module, but the three most important functions are:
  \begin{itemize}
    \setlength\itemsep{0em}
    \item \verb|random.random()|: produces a random real number between 0 and 1
    \item \verb|random.randint(a,b)|: produces a random integer between \verb|a| and \verb|b|.
    \item \verb|random.sample(population, k)|: Chooses \verb|k| unique random elements from a \verb|population|.
  \end{itemize}
  \marginnote{4.1.1.9}Exception Handling is the process of dealing with events that cause the current subroutine/ procedure to stop. In general this is done by:
  \begin{enumerate}
    \setlength\itemsep{0em}
    \item An error is thrown causing the current subroutine to stop.
    \item The current state of the subroutine is saved.
    \item The exception handling (or catch) block is executed to take care of the error.
    \item the normal subroutine can continue from where it left off.
  \end{enumerate}
  In python, exception handling is done by using \verb|try| and \verb|except|. Here is a relatively simple example:
  \begin{python}
Age = input("Please Input Your Age: ")

try:
	Age = int(Age)
except:
	print("Age is not an Integer please try again.")
else:
	print("Your age is %i"%(Age))
\end{python}
  What this code does is it first asks the user to input their age. We then go into the exception handling part where the code tries to make the input an integer. If an error occurs then the program prints \verb|"Age is not an Integer please try again."|, if no errors occur, then the program prints out the age inputted at the start of the program.
  \marginnote{4.1.1.10}A subroutine is self-contained and it carries out one or more related processes, subroutines must be given unique identifiers or names, which means that once they have been written they can be called using their name at any time while the program is being run. Subroutines can be written to handle events (something that happens during runtime).\\
  The benefits of using subroutines are as follows:
  \begin{itemize}
    \setlength\itemsep{0em}
    \item They can be called at any time.
    \item They allow for an easy overview of the program.
    \item Can use a top-down approach to develop a project.
    \item Easier to debug as each subroutine is self-contained.
    \item Large projects can be developed by multiple programmers
  \end{itemize}
  \marginnote{4.1.1.11}A Subroutine often has parameters and Argument. Parameters are pieces of data that represents data to be passed into a subroutine and an argument is a piece of data that is passed into the subroutine. For example if you defined a subroutine \verb|LoadGame(Filename, Board)| Filename and Board are parameters, later when it is called as \verb|LoadGame(TRAININGGAME, Board)| the variables TRAINNINGGAME and Board are the arguments. To pass the arguments into the subroutine a block interface is used, which is code that describes the data being passed into the subroutine.\\
  \marginnote{4.1.1.12} To define a subroutine/ function in python we use the keyword \verb|def| and to add arguments brackets are used after the subroutine name. so if we wanted to define a function named Add\_Contact which has the parameters Name, and Address, we would write \verb|def Add_Contact(Name, Address):| for the function to return a value you simply use \verb|return| followed by the data you want the function to return to the calling routine.\\
  \marginnote{4.1.1.13}Within a subroutine (in python) any variable that isn't declared as a global variable, is considered a local variable, meaning that it only exists within the subroutine, and once the subroutine has finished, the variable would no longer exist, so they cannot be accessed outside of the subroutine. There are three main benefits to this which are:
  \begin{itemize}
    \setlength\itemsep{0em}
    \item Can't inadvertently change the value being stored elsewhere in the program.
    \item Use the same identifier in several places and have them be consider different variables.
    \item Free up memory as each time a local variable is finished with it is removed from memory.
  \end{itemize}
  \marginnote{4.1.1.14} The difference between a local and global variable is that a local variable has a limited existance within a subroutine or function in which it was declared whereas a global variable can be used anywhere in the program.
  
  \noindent
  \marginnote{4.1.1.15}whenever a program is being executed, it will have to deal with functions from on part of the program returning values to other parts of the program. To deal with this, we use a call stack which takes care of all the times a function is called and where to return the values of the function. The call stack in itself is made up of stack frames, which in themselves are made of three main parts:
  \begin{itemize}
  	\item The arguments to be passed
  	\item The address the final output should be returned to (the return address)
  	\item The local variables of the subroutine
  \end{itemize}
  There is another part of the stack frame called the frame pointer which points to the part of the just before the function is called, which often means it will be before the local variables of the subroutine, but after the return address, the frame pointer is useful as not all functions will have the same number of local variables, so the stack size can vary, so it is often useful to have this stack pointer to easily be able to restore the stack to the state before the function was called.
  
  \noindent
  \marginnote{4.1.1.16}Recursion is the process of a subroutine calling itself in order to complete a task. The most simple example of recursion is to calculate n factorial ($n! = n\times(n-1)\times(n-2)\times\cdots\times3\times2\times1$).
  
  \begin{python}
def factorial(n):
	if n==0:
		return 1
	else:
		return n * factorial(n-1)\end{python}
  
  In this example it is clear to see that there's a base case (a case where you return a value that does not call itself), which in this case is return 0 if n equals 0, and a general case (the case that calls upon the function itself) which in this case was return $n \times (n-1)!$
\subsection{Programming Paradigms}
  \noindent
  \marginnote{4.1.2.1}A programming paradigm can be thought of as the way in which we structure our programs. A procedural programming paradigm involves us just writing out step by step instructions for our program to follow, and then executing our program. In object oriented program, we deal with objects and the way in which they are related to one another and the way in which they are allowed to interact with one another, which is very useful when trying to model groups of things such as te animal kingdom.

  \noindent
  \marginnote{4.1.2.2}Hierarchy or Structure Charts use a top-down approach to explain how a program is put together, meaning it starts from the program name and breaks the problem down into smaller pieces. A Structure Chart differs from a Hierarchy Chart as a Structure Chart shows how data flows through a system, whereas a Hierarchy Chart does not. An example of a Hierarchy Chart is as follows:
  \begin{figure}[H]
    \centering
    \begin{tikzpicture}[
    level 1/.append style={level distance=2cm},
    level 2/.append style={level distance=2cm}]
      \tikzstyle{every node}=[rectangle, rounded corners, minimum width=2cm, minimum height=1cm,text centered, draw=black]
      \Tree
        [.Program
          [.{Initialise} ]
          [.{Input}
            [.{Capture Form} ]
            [.{Enter Data} ]
            [.{Validate} ]
          ]
          [.{Process} ]
          [.{Output} ]
        ]
    \end{tikzpicture}
  \end{figure}
  \noindent
  A flowchart is a diagram using standard symbols that describes a process or system. A system flowchart is a diagram that shows individual processes within a system. It often possible to create just one flowchart that shows the entire system, but this is not always a good idea as modern programs can be very large and putting every process on to one flowchart might make it too complex to be of any real use. This can be fixed by having multiple flowcharts for the multiple systems.\\
  Pseudo-code is a method of writing code that does not require knowledge of a particular programming language without having to worry about syntax or constructs. The only true rule of Pseudo-code is that it has to be internally consistent, for example if you write \verb|print| in one place and then write \verb|output|, this is considered bad practice and also makes it harder to convert it to a programming language later.\\
  Pseudo-code can be used at many levels of detail meaning it is up to the programmer to decide what level of detail is appropriate to the project they are planning to do. One of the major benefits of using Pseudo-code is it allows the programmer to see how his code may eventually be laid out.\\
  Naming Conventions is the process of giving meaningful names to subroutines, functions, variables and other user-defined features in a program. Before coding, a list of all the variables, including their data type and scope (Global or local) should be made. A similar procedure should also be carried out for all functions and subroutines to be featured within the program.\\
  When writing the actual code, you should try and make your program as programmer-friendly  as possible with the use of code layout and comments, examples of this would be:
  \begin{itemize}
    \setlength\itemsep{0cm}
    \item Comments to show the purpose of an algorithm.
    \item Comments to show the purpose of each line.
    \item Sensible variable names.
    \item Indenting the contents of loops and subroutines.
  \end{itemize}
  After the code is initially written, debugging will often have to occur. This can be done using a dry run and a trace table. A dry run is the process of stepping through each line of code to see what will happen before a program is run, a trace table is a method of recording the result of each step that takes place when dry running code.
  
  \noindent
  \marginnote{4.1.2.3}Object-Oriented Programming is a way of programming in which we try and organise objects in a way that reflects the real world. There are some basic concepts that we should define first:
  \begin{itemize}
  	\item class
  	\item object
  	\item instantiation
  \end{itemize}
  A class is used to define all all fo the properties (the defining features of the class, the variables) and methods (the things that the class can do, the functions) that are core to a group of similar objects (in the non computing sense). An Object is an instance of a class so for example, if we were to say that the human race was a class, you would by an object of that class. Instantiate is the process of creating an object from a class, following our humans example, giving birth would be instantiation. An example of the difference in python would be
  \begin{python}
class Humans:
	def __init__(self,age,height,name):
		self.age = age
		self.height = height
		self.name = name

nathan = Humans(18,1.95,"Nathan")\end{python}
  Here we can see that Humans is the class, nathan is an object from the class humans, and the way that we instantiate Human objects is through a constructor (which constructs an object) like: Humans(18,1.95,"Nathan")
  
  One of the first concepts within Object Oriented Programming we will talk about is encapsulation. This is the idea that the properties and the methods that manipulates that properties should be in the same class, meaning the class is self contained. This means it is less likely that the property of a class will be occidentally affected by other parts of the program. This process may also be called information hiding as the properties are available within the class but not outside it.
  
  Another concept is the concept of inheritance, this is the idea that a parent class can share its properties and its methods with a child/ sub class. With inheritance, you may consider starting off with a base class and then building children off of that. This base class should contain properties and methods that are common to all of its children. With our humans example, we could re-write the code so that it is a child of a class called Animals and let Animals also have other children classes. A coding example of this would be:
  \begin{python}
class Animals:
	animals = []
	nextID = 0

	def __init__(self,age,height):
		self.id = Animals.nextID
		self._age = age
		self._height = height
		Animals.nextID+=1
		Animals.animals.append(self)

	def getAge(self):
		return self._age

	def getheight(self):
		return self._height

class Humans(Animals):
	def __init__(self,age,height,name):
		Animals.__init__(self,age,height)
		self.__name = name

	def speak(self):
		print("hello")

	def getName(self):
		return self.__name

class Dog(Animals):
	def __init__(self,age,height):
		Animals.__init__(self,age,height)

	def Bark(self):
		print("bark")
  	\end{python}
  	
  	Inheritance can be shown using a diagram. The class diagram follows the following rules.
  	\begin{itemize}
  		\item It is hierarchical in structure, with the base class on top.
  		\item arrows indicate direction of inheritance
  		\item Each class is represented by a box containing three sections
	  		\subitem Name
	  		\subitem Properties
	  		\subitem Methods
  		\item If class A inherits from class B, a hollowed triangle arrow drawn from class A to class B.
  		\item If object A is a composite aggregate of class B and C, a filled diamond arrow drawn from class B to class A and from class C to class A.
  		\item If object A is a associate aggregate of class B and C, a hollowed diamond arrow drawn from class B to class A and from class C to class A.
  		\item If a class method/ property is private (can only be accessed within the class), prefix it with a -
  		\item If a class method/ property is public (can be accessed anywhere within the program), prefix it with a +
  		\item If a class method/ property is protected (can be accessed by the class and all of its children), prefix it with a \#
  	\end{itemize}
  	
  	\begin{figure}[H]
  		\centering
	  	\includegraphics[scale=0.7]{Class-Diagram}
    \end{figure}
  	The third concept you need to know about is Aggregation, this is a way of creating new objects (meaning 2 or more) from objects that already exist. There are two types of aggregation, association aggregation and composition aggregation. With composition Aggregation (AKA composition) this implies that the one ``parent'' object owns the other ``child'' objects, an example would be a university and its departments, if the university were to shut down, then all of the departments would also have to shut down as the university owns the departments. With association aggregation if the parent object is destroyed, this does not necessarily mean the child objects would be destroyed. An example would be a department and its professors, if the department is shut down, the professors still exist, they just have to find work else where.
  	
  	The final concept is polymorphism, this is the idea that a method defined in a base class can be redefined in classes that inherit from it, and thus be used in different ways. When the method defined within the sub class takes precedence over the same method defined in the base class, this is called overriding.
  	
  	There are several advantages to using an Object-oriented programming Paradigm:
  	\begin{itemize}
  		\item It is easier to follow a modular approach to programming, thus making editing and appending programs easier
  		\item Easy to add functionality to a module
  		\item Modular design allows teams of programmers to easily work on self-contained modules
  		\item Inheritance means code made more easily reusable throughout the program
  		\item Less likely to cause bugs as only edit something within one class
  		\item Libraries of classes can be created for easy code reuse
  	\end{itemize}
  	
  	There are 3 design principles within object oriented Programming
  	\begin{itemize}
  		\item Encapsulate what varies
  		\subitem This is basically saying that break the problem down into as many classes as necessary to represent the problem in a way that adequately models the world around us. If you find a class should be broken up further, then break it up.
  		\item Favour composition over inheritance
  		\subitem For inheritance you would need to create a new class that inherits from other classes, whereas with composition or association aggregation, if you know the original classes work, you just need to instantiate the classes and combine the objects, which is less error prone.
  		\item Program to interfaces not to implementations
  		\subitem Program classes so that if they are related in some way they share methods that will carry out similar functions on similar pieces of data(if you want some experience with interfaces, I would suggest looking into learning some basic java) instead of creating many classes with lots of different classes which carry out the same function, but with different method names. (An example of where I broke this above is with the speak method in Humans and the bark method in Dogs, I could have easily moved the speak method into the Animals class and then overridden them in the sub classes, which would make the classes more logically coherent).
  	\end{itemize}
  	
  	For the exam, you should be able to write object oriented programs and have experience in coding the following:
  	\begin{itemize}
  		\item abstract methods
	  		\subitem A method that is declared but has no implementation
  		\item virtual methods
	  		\subitem A method defined in the base class which can be overridden. Its purpose is to allow the program on run time to decide at run-time what version of the method to run based on the instance used.
  		\item static methods
  		\item inheritance
  		\item aggregation
  		\item polymorphism
  		\item public, private and protected specifiers
  	\end{itemize}
  	
  	Below I'm going to show a quick example of how to do each of the above in python
  	
  	\textbf{abstract methods}
  	
  	\begin{python}
#Abstract Base Class
import abc

Class A:
	@abc.abstractMethod
	def methodToDefine(self,input):
		return\end{python}
	
	\textbf{virtual methods} - thankfully in python all methods are \textit{technically} virtual due to duck typing (Google it).
	
	\textbf{static methods}
	
\begin{python}
Class A:
	@staticmethod
	def printHi():
  		print("Hi")\end{python}	
  	
  	\textbf{Inheritance}, where class B inherits from class A
  	
\begin{python}
class A:
	pass

class B(A):
	pass
\end{python}
	
	\textbf{Association Aggregation}, where class A and class B make class C

\begin{python}
class A:
	pass

class B:
	pass

class C:
	def __init__(self, a1, b1)
		self.a = a1
		self.b = b1
		
obj_a = A()
obj_b = B()
obj_c = C(a,b)
\end{python}

	\textbf{Composition Aggregation}, where class A and class B make class C
	
\begin{python}
class A:
pass

class B:
pass

class C:
def __init__(self)
self.a = A()
self.b = B()
\end{python}
	
	polymorphism
\begin{python}
class A:
	def printWelcoming(self):
		print("Hi")
	
class B(A):
	def printWelcoming(self):
		print("Hello")
\end{python}

	\textbf{Public, Private, and Protected specifiers}

\begin{python}
class A:
	def __init__(self,a1,b1,c1)
		"""self.a is public"""
		self.a = a1
		"""self.b is protected"""
		self._b = b1
		"""self.c is private"""
		self.__c = c1
	
\end{python}