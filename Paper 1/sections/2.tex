\subsection{Data Structures and Abstract Data Types}
  \marginnote{4.2.1.1}A data structure is any method used to store data in an organised and accessible format, they normally contain data that are related, different data structures allow for different data manipulations which means different data structures are use for different types of applications. For example an array may be useful to store a list of names whereas a textfile may be used to store information for a database.
  \marginnote{4.2.1.2}An array is a set of related data items stored under a single identifier, they can have one or more dimensions, all elements are often of the same type(homogeneous). An array most commonly has either one dimension(which can be useful to represent vectors) which can be visualised using a list, or two dimensions (which is useful for representing a matrix) which can be visualised using a two-dimensional table. In python, instead of Arrays we use lists, which have a few minute differences to standard arrays (python lists are heterogeneous(They can store dat of different types)) but can be used in the same way as arrays. Some uses of lists are as follows:
  \begin{python}
Studentname = ["Derrick","Gill","Jamal","Lois"]
Studentname[1]
'Gill'

ArrayAdd=[[0,1,2],[1,2,3],[2,3,4]]
ArrayAdd[1][2]
3		\end{python}
  \marginnote{4.2.1.3}Files are used to store many different types of data meaning that many different file types are needed to store all of these different types of data. Many file types are portable meaning that they can be used on many different platforms, the two most common portable file types when programming are text files (which is a file that contains human readable characters) and binary files (which stores data as 1s and 0s). One line on a text file may be referred to as a record, and the different items of data stored within the record are called the fields.\\
  All files have an internal structure which allows them to store data efficiently, there are two common structures that are used to store data These are:\\
  Tab-delimited text (txt) file:
  \begin{csv}
Sara	Phillips	sphillips0@google.co.jp	Female	117.135.192.97
Laura	Harvey	lharvey1@utexas.edu	Female	62.114.62.185
Eugene	Wells	ewells2@weibo.com	Male	119.176.45.229
Helen	Jordan	hjordan3@geocities.jp	Female	81.49.64.62
Shirley	Weaver	sweaver4@pbs.org	Female	218.20.41.34	\end{csv}
  Comma seperate variable (csv):
  \begin{csv}
Sara,Phillips,sphillips0@google.co.jp,Female,117.135.192.97
Laura,Harvey,lharvey1@utexas.edu,Female,62.114.62.185
Eugene,Wells,ewells2@weibo.com,Male,119.176.45.229
Helen,Jordan,hjordan3@geocities.jp,Female,81.49.64.62
Shirley,Weaver,sweaver4@pbs.org,Female,218.20.41.34 	\end{csv}
  To read and write to csv, we can use the python module csv:
  \begin{python}
import csv
file=open("Contacts.csv","a+",newline='')
Reader = csv.reader(file) # This reads the contents of the file
Writer = csv.writer(file) # This creates an object which allows us to write to the file.
file.write("\n")
Writer.writerow(['Joe', 'Shmuck', 'JShmuck3D@hotmail.com', 'Male','162.148.10.205'])
file.close()	\end{python}
  Binary files contain binary codes and usually contain some header information that describes what these represent, binary files are not easily readable by a human, but can quickly be interpreted by a program. For example, the PNG image file is a binary file, can be used in a range of applications and requires less memory than some other image formats. Many program files (executables) are binary files so they can be used on other platforms. The two main actions you might want to perform on binary files are to read and write data from and to it.
  
  
  \marginnote{4.2.1.4}An abstract data is the conceptual model of how data should be stored and the operations that can be done on this data. Data structures are the physical implementations of these abstract data types within a programming language. There are a large arrange of abstract data types, the ones needed for the exam are as follows:
  \begin{itemize}
  	\item Queue
  	\item Stack
  	\item List
  	\item Graph
  	\item Tree
  	\item Hash Table
  	\item Dictionary
  	\item Vector
  \end{itemize}
  When considering data structures, they can be split up into two groups: static, and dynamic. Static data structures can only hold use a certain amount of memory, usually defined by the programmer, whereas dynamic data structures can change in size, using more or less memory as needed. Dynamic and data structures have their independant advantages and disadvantages:
  \begin{table}[H]
  	\begin{tabular}{| C{7cm} | C{7cm} |}
  		\hline
  		\textbf{Static Data Structures} & \textbf{Dynamic Data structures} \\\hline
  		Inefficient as memory is allocated that may not be needed & Efficient as the amount of memory used varies as needed \\\hline
  		Fast access to each element of data as the memory locations are fixed when the program is written, thus they will be contiguous & Slower access to each element as the memory is allocated at run time so may be fragmented. \\\hline
  		Structures are a fized size, making them more predictable to work with. & Structures vary in size so there needs to be a mechanism for knowing the size of the current structure. \\\hline
  	\end{tabular}
  \end{table}
\subsection{Queues}
  
  \marginnote{4.2.2.1}The queue is a FIFO (First in First Out) structure (meaning the first value into the structure, will be the first out). A queue acts like a queue in a shopping market, the first person into the queue, will be the first to be serviced.\\
  To implement a queue, we use a front and rear pointer to represent the front and back of the queue respectively. To explain the general operations of a queue we will use an example on a small scale with a queue (capable of storing a max of 6 items) with some values already in it:
  \begin{table}[H]
  	\begin{tabular}{C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm}}
  		Front Pointer & & & Rear Pointer & & \\\hline
  		\multicolumn{1}{|c|}{``Nathan''} & \multicolumn{1}{|c|}{``Tashy''} & \multicolumn{1}{|c|}{``Giorgia''} & \multicolumn{1}{|c|}{``Ryan''} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{}\\\hline
  	\end{tabular}
  \end{table}
  
  If we wanted to add to this queue, we would add to the end queue, and then move the rear pointer to the address of the new item. So in this example if we were to add the name ``Helen to the queue'', the structure would become:
  \begin{table}[H]
  	\begin{tabular}{C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm}}
  		Front Pointer & & & & Rear Pointer & \\\hline
  		\multicolumn{1}{|c|}{``Nathan''} & \multicolumn{1}{|c|}{``Tashy''} & \multicolumn{1}{|c|}{``Giorgia''} & \multicolumn{1}{|c|}{``Ryan''} & \multicolumn{1}{|c|}{``Helen''} & \multicolumn{1}{|c|}{}\\\hline
  	\end{tabular}
  \end{table}
  If we wanted to delete from the queue, we always delete from the front, and the front pointer moves on to the next item, so in this case if we were to delete an item, the queue would become:
  \begin{table}[H]
  	\begin{tabular}{C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm}}
  		 & Front Pointer & & & Rear Pointer & \\\hline
  		\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{``Tashy''} & \multicolumn{1}{|c|}{``Giorgia''} & \multicolumn{1}{|c|}{``Ryan''} & \multicolumn{1}{|c|}{``Helen''} & \multicolumn{1}{|c|}{}\\\hline
  	\end{tabular}
  \end{table}
  The example above shows an implementation of a queue called a linear queue, where the queue can be visualised as a straight line. Other implementations of a queue include the circular queue and priority queue (although this structure varies slightly from a normal queue in that it adds a priority attribute to each element).
  
  With the linear queue, it is possible that if we were to implement it using a static data structure such as an array, it is possible that the queue has no elements and is thus empty, or the queue has used all the elements in the array, thus being full. tests are needed for both of these scenarios, as well as the name, maximum size, and the position of the pointers when the queue is initialised. You may have also noticed that in our example, if two more names were added to the array, then the rear pointer would be out of the range of the array and cause an array. A fix for this could be to shift all the elements of the array back when an element is removed, however this could be a long operation if they are using a longer queue. Another way to solve this problem is to use a circular queue.
  
  A solution to the problem that is caused by linear queues is to implement a circular queue, this queue uses the same underlying concept of a linear queue, however whenever the pointer would go out of bounds, it instead wraps around to the beginning of the array, causing it the array to act as if it is a circle. If we were to use an example of adding two names to the example queue, then delete a name, here is what it would look like:
  
  Add the Name Anik:
    
  \begin{table}[H]
  	\begin{tabular}{C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm}}
  		& Front Pointer & & & & Rear Pointer \\\hline
  		\multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{``Tashy''} & \multicolumn{1}{|c|}{``Giorgia''} & \multicolumn{1}{|c|}{``Ryan''} & \multicolumn{1}{|c|}{``Helen''} & \multicolumn{1}{|c|}{``Anik''}\\\hline
  	\end{tabular}
  \end{table}
  
  Add the Name Bilal:
  
  \begin{table}[H]
  	\begin{tabular}{C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm}}
  		Rear Pointer & Front Pointer & & & & \\\hline
  		\multicolumn{1}{|c|}{``Bilal''} & \multicolumn{1}{|c|}{``Tashy''} & \multicolumn{1}{|c|}{``Giorgia''} & \multicolumn{1}{|c|}{``Ryan''} & \multicolumn{1}{|c|}{``Helen''} & \multicolumn{1}{|c|}{``Anik''}\\\hline
  	\end{tabular}
  \end{table}
  
  Delete a name:
  
  \begin{table}[H]
  	\begin{tabular}{C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm} C{1.5cm}}
  		Rear Pointer & & Front Pointer & & & \\\hline
  		\multicolumn{1}{|c|}{``Bilal''} & \multicolumn{1}{|c|}{} & \multicolumn{1}{|c|}{``Giorgia''} & \multicolumn{1}{|c|}{``Ryan''} & \multicolumn{1}{|c|}{``Helen''} & \multicolumn{1}{|c|}{``Anik''}\\\hline
  	\end{tabular}
  \end{table}
  
  
\subsection{Stacks}
  
  \marginnote{4.2.3.1}Stacks
\subsection{Graphs}
  
  \marginnote{4.2.4.1}Graphs
\subsection{Trees}
  
  \marginnote{4.2.5.1}Trees
\subsection{Hash Tables}
  
  \marginnote{4.2.6.1}Hash Tables
\subsection{Dictionaries}
  
  \marginnote{4.2.7.1}Dictionaries
\subsection{Vectors}
  
  \marginnote{4.2.8.1}Vectors