\subsection{Hardware and Software}
  \noindent
  \marginnote{3.6.1.1}Hardware is a generic term for the physical parts of the computer, both internal and external. Software is a generic term for any program that can be run on a computer. Thus we get the relationship that software is run on hardware.\\
  \marginnote{3.6.1.2}There are several different types of software:
  \begin{itemize}
    \setlength{\itemsep}{0em}
    \item Application Software
      \subitem This is software that perform specific tasks for the user. Some examples are word processors, spreadsheets, and web browsers.
    \item \marginnote{3.6.1.3} System Software
      \subitem This is software that is needed for the computer to run, they support the application software. There are several forms of application software:
      \begin{itemize}
        \setlength{\itemsep}{0em}
        \item Utility Programs
        \subitem This is software that is written to carry out certain housekeeping tasks on hardware, they usually come with the OS and help to enhance your computer, however your computer can work without them, examples are compression software, anti-virus software, back-up software, registry cleaners.
        \item Library Programs
        \subitem this is a large amount of different pieces of software that are in general important for applications to work, as they usually call data from within this software. An example is Windows Dynamically linked libraries, which are called upon whenever windows needs it, they contain code, data, and resources.
        \item Translators (Compilers, Assemblers, and Interpreters)
        \subitem A translator is software that converts high level programming languages into machine code (1s and 0s) so that it can carried out by the machine.
        \item Operating Systems (OS)
        \subitem This is a suite of programs designed to control the operations of the computer, it acts as the interface between the user and computer.
      \end{itemize}
  \end{itemize}
  \marginnote{3.6.1.4}The OS links together the hardware, applications and the user, but hides the true complexity of the computer from the user and other software by using a virtual machine. Some examples of the tasks that the OS performs are as follows:
  \begin{itemize}
    \item Configure the start configuration of your computer
    \item recognising inputs from I/O devices and deciding what to do
    \item Attempts to cope with errors as they occur
    \item controls the shutting down of the computer
    \item controls print queues
    \item manages users on a network
    \item Resource Management
    \subitem This is the way in which an OS manages hardware and software to optimise the performance of the computer. If a computer features one processor, then only one process (and thus one application) can actually be alive at any time, so to simulate having multiple applications being run at the same time the computer has to schedule how different programs are able to use the processor. A common type of scheduling is Round-Robin scheduling, where each task has an equal amount of time using the processor. This can be inefficient as some processes may need little or none of the time allocated to them, so a more advanced scheduling system would allocate this time to another task before the time slice ran out.
    \begin{itemize}
      \setlength{\itemsep}{0em}
      \item Managing I/O devices
        \subitem The operating controls the way in which I/O devices are allocated, controlled and used by programs that are using them. Due to the fact that I/O devices work relatively slow when compared to the processor, a queue of commands for a certain device, which the device can carry out in order when it is ready. Every I/O device has a driver which allows the OS to interact with that device.
      \item Memory Management
        \subitem This deals with how RAM is allocated to different files and applications. The OS stores data of all unallocated memory addresses in a section of memory called the heap, when a file is opened, it is assigned memory from the heap, and when it is closed, the memory locations are put back into the heap. It is te task of the memory management routines to manage the assignment of memory and to load the necessary files to their respective memory address. The OS uses a memory so that it knows what places in the memory are taken up so the OS can control more than one task in the ram at any one time.
        The amount of RAM a program depends it's size and complexity.
      \item Virtual Memory and paging
        \subitem When a file or application is too big to fit in RAM, part of the secondary memory may be allocated to store memory that is usually held in RAM and treats this part of the secondary memory as if it were RAM, this is called virtual memory. An alternative method is to store the central block of the code in the RAM and then call upon other sections of code (called pages) from secondary memory as they are needed, this allows large applications to run in a small part of the RAM.
      \item File Management
        \subitem This concerns how the OS stores and retrieves files from secondary memory. The OS uses a hierarchical structure, which allows you to have files of the same name as long as they are in different folders. Larger hard disks have lended themselves to the idea of partitions, which means that one hard drive can act as two logical drives so, to your computer, it would seem like you have two hard drives.
    \end{itemize}
  \end{itemize}
\subsection{Classification of Programming Languages}
  \noindent
  \marginnote{3.6.2.1}There are many different programming languages, some closely reflect the architecture of the computer (low-level languages) while others more reflect the way we naturally speak (high-level languages).\\
  There are two main low level languages:
  \begin{itemize}
    \item Machine Code
      \subitem This is the lowest level of code which is made up of 0s and 1s, this is the only format that the processor can process. Due to the fact that it is simply a sequence of 1s and 0s, it can make it very unwieldy to read and write, and also means there's a large chance of mistakes. One way to make it easier is to Hexadecimal or decimal numbers to show a sequence of bits. If the code does have an error, it can be very hard track down, also due to the fact that you are writing directly to one specific processor, it is unlikely to be portable, however this also means that it is likely to run quickly on that specific processor and do exactly what you said.
    \item Assembly Language
      \subitem Assembly language is more programmer as it allows programs to use mnemonics which translate to one command in machine code, there is a one-to-one relationship. The number of mnemonics used in an assembly language is usually quite small. Assembly language can be quite difficult to read but has many benefits: programs are executed quickly due to the fact that a compiler cannot optimise code as well as a programmer, program code is relatively compact for the same reason, direct manipulation of registers leads to a high level of control. For theses reasons it is used for projects where quick responses are needed or low level interactions, such as embedded systems, real time apps, and device drivers.
  \end{itemize}
  A High level programming language is a programming language that allows programs to be written using English keywords and that is platform independent. These are problem-oriented, meaning that they are created to overcome a certain problem, not made for a specific computer architecture, so they are portable. Imperative languages (Also known as procedural languages) are languages that work by typing in lists of instructions (subroutines/procedures) that the computer has to follow. Every time the program is run, the same set of instructions are run.\\
  High level languages are related to low level languages because high level languages must be translated to low level languages (specifically machine code) in order to be understood by the computer. Some of the main features are:
  \begin{itemize}
    \setlength{\itemsep}{0em}
    \item Easy to identify what a town does
    \item They need to be translated
    \item One high level command translates to many machine code commands, there is a one-to-many relationship
    \item They are portable
    \item They are easy to maintain via use of a wide range of program structures.
  \end{itemize}
\subsection{Types of Program Translator}
  \noindent
  \marginnote{3.6.3.1} There are three types of translators:
  \begin{itemize}
    \item Assembler
      \subitem An assembler is a program that translates a program written in assembly language into machine code.
    \item Compiler
      \subitem A compiler is a program that translates high level language into machine code by translating all of the code.
    \item Interpreter
      \subitem An interpreter is a program that translates high level language by reading each statement in the source code and immediately performing the action.
  \end{itemize}
  \begin{table}[H]
    \centering
    \begin{tabular}{|C{4cm}|C{4cm}|C{4cm}|C{4cm}|} \hline
      \multicolumn{2}{|c|}{Interpreter} & \multicolumn{2}{c|}{Compiler} \\ \hline
      Advantage & Disadvantage & Advantage & Disadvantage \\ \hline
      You don't need to compile the whole program in order to run a section of the code & Sections of the code that are revisited in a program will need translating each time, meaning longer execution time & Once compiled, source code no longer needed & Whole program has to be translated when slight alterations are made, meaning debugging takes a long time\\ \hline
      Program code can be run on processors with different instruction sets. & Source Code can only be translated thus executed on a computer with the same interpreter. & Difficult to reverse engineer source code from object code. & The object code will only run on a computer that has the same platform. \\ \hline
      Mostly like to be used during development. & The source code must be distributed. & \multicolumn{2}{c}{} \\ \cline{1-2}
    \end{tabular}
  \end{table}
  Some programming languages use bytecode, which is an instruction set that can be executed using a virtual machine. This virtual machine can emulate the instruction set of the architecture of the computer, meaning that the source code written using bytecode can be executed on any platform.
\subsection{Logic Gates}
  \marginnote{3.6.4.1}These are the logic gates that you need to know:
    \begin{longtable} {C{2cm} C{5cm} C{5cm}}
    \textbf{Logic Gate Name} & \textbf{Truth Table} & \textbf{Logic Gate Symbol} \\
    AND &
    \begin{tabular}{|cc|c|} \hline
      $A$ & $B$ & $A\bullet B$ \\ \hline
      0 & 0 & 0 \\
      0 & 1 & 0 \\
      1 & 0 & 0 \\
      1 & 1 & 1 \\ \hline
    \end{tabular} &
    \begin{tikzpicture}
      \node[and gate US, draw,minimum size=1cm](and1){};
      \node at ([xshift=-20pt]and1.input 1) (A){$A$};
      \node at ([xshift=-20pt]and1.input 2) (B){$B$};
      \node at ([xshift=40pt]and1.output) (Q){$Q=A\bullet B$};
      \draw (and1.input 1) -- (A);
      \draw (and1.input 2) -- (B);
      \draw (and1.output) -- (Q);
    \end{tikzpicture}
    \\ & & \\
    OR &
    \begin{tabular}{|cc|c|} \hline
      $A$ & $B$ & $A+B$ \\ \hline
      0 & 0 & 0 \\
      0 & 1 & 1 \\
      1 & 0 & 1 \\
      1 & 1 & 1 \\ \hline
    \end{tabular} &
    \begin{tikzpicture}
    \node[or gate US, draw,minimum size=1cm](and1){};
    \node at ([xshift=-20pt]and1.input 1) (A){$A$};
    \node at ([xshift=-20pt]and1.input 2) (B){$B$};
    \node at ([xshift=40pt]and1.output) (Q){$Q=A+B$};
    \draw (and1.input 1) -- (A);
    \draw (and1.input 2) -- (B);
    \draw (and1.output) -- (Q);
    \end{tikzpicture}
    \\ & & \\
    NOT &
    \begin{tabular}{|c|c|} \hline
      $A$ & $\overline{A}$ \\ \hline
      0 & 1 \\
      1 & 0 \\ \hline
    \end{tabular} &
    \begin{tikzpicture}
    \node[not gate US, draw,minimum size=1cm](and1){};
    \node at ([xshift=-20pt]and1.input) (A){$A$};
    \node at ([xshift=40pt]and1.output) (Q){$Q=\overline{A}$};
    \draw (and1.input) -- (A);
    \draw (and1.output) -- (Q);
    \end{tikzpicture}
    \\ & & \\
    NAND &
    \begin{tabular}{|cc|c|} \hline
      $A$ & $B$ & $\overline{A\bullet B}$ \\ \hline
      0 & 0 & 1 \\
      0 & 1 & 1 \\
      1 & 0 & 1 \\
      1 & 1 & 0 \\ \hline
    \end{tabular} &
    \begin{tikzpicture}
    \node[nand gate US, draw,minimum size=1cm](and1){};
    \node at ([xshift=-20pt]and1.input 1) (A){$A$};
    \node at ([xshift=-20pt]and1.input 2) (B){$B$};
    \node at ([xshift=40pt]and1.output) (Q){$Q=\overline{A\bullet B}$};
    \draw (and1.input 1) -- (A);
    \draw (and1.input 2) -- (B);
    \draw (and1.output) -- (Q);
    \end{tikzpicture}
    \\ & & \\
    NOR &
    \begin{tabular}{|cc|c|} \hline
      $A$ & $B$ & $\overline{A+B}$ \\ \hline
      0 & 0 & 1 \\
      0 & 1 & 0 \\
      1 & 0 & 0 \\
      1 & 1 & 0 \\ \hline
    \end{tabular} &
    \begin{tikzpicture}
    \node[nor gate US, draw,minimum size=1cm](and1){};
    \node at ([xshift=-20pt]and1.input 1) (A){$A$};
    \node at ([xshift=-20pt]and1.input 2) (B){$B$};
    \node at ([xshift=40pt]and1.output) (Q){$Q=\overline{A+B}$};
    \draw (and1.input 1) -- (A);
    \draw (and1.input 2) -- (B);
    \draw (and1.output) -- (Q);
    \end{tikzpicture}
    \\ & & \\
    XOR &
    \begin{tabular}{|cc|c|} \hline
      $A$ & $B$ & $A\oplus B$ \\ \hline
      0 & 0 & 0 \\
      0 & 1 & 1 \\
      1 & 0 & 1 \\
      1 & 1 & 0 \\ \hline
    \end{tabular} &
    \begin{tikzpicture}
    \node[xor gate US, draw,minimum size=1cm](and1){};
    \node at ([xshift=-20pt]and1.input 1) (A){$A$};
    \node at ([xshift=-20pt]and1.input 2) (B){$B$};
    \node at ([xshift=40pt]and1.output) (Q){$Q=A\oplus B$};
    \draw (and1.input 1) -- (A);
    \draw (and1.input 2) -- (B);
    \draw (and1.output) -- (Q);
    \end{tikzpicture}
    \\
    \end{longtable}
  \noindent
  Logic Gates can be combined in order to create more complex boolean expressions, for example $Q = A \bullet B + C$ can be expressed using the following logic gate:
  \begin{figure}[H]
    \centering
    \begin{tikzpicture}
    \node[and gate US, draw, minimum size=1.5cm] (and1) {};
    \node[or gate US, draw, minimum size=1.5cm] at ([xshift=60pt, yshift=-30pt]and1.output) (or1) {};
    \node at ([xshift=-30pt]and1.input 1) (A){$A$};
    \node at ([xshift=-30pt]and1.input 2) (B){$B$};
    \node at (or1.input 2 -| B) (C) {$C$};
    \node at ([xshift=60]or1.output) (Q) {$Q=A \bullet B + C$};
    \draw (and1.input 1) -- (A);
    \draw (and1.input 2) -- (B);
    \draw (and1.output) -- ++(right:7mm) |- node[above=8mm] {$A \bullet B$} (or1.input 1);
    \draw (C) |- (or1.input 2);
    \draw (or1.output) |- (Q);
    \end{tikzpicture}
  \end{figure} \noindent
  We can also construct logic tables from logic diagrams, we can show how this may be done using the logic diagram above as an example:
  \begin{table}[H]
    \centering
    \begin{tabular}{|ccc|c|c|} \hline
      $A$ & $B$ & $C$ & $A \bullet B $ & $A \bullet B + C$ \\ \hline
      0 & 0 & 0 & 0 & 0 \\
      0 & 0 & 1 & 0 & 1 \\
      0 & 1 & 0 & 0 & 0 \\
      0 & 1 & 1 & 0 & 1 \\
      1 & 0 & 0 & 0 & 0 \\
      1 & 0 & 1 & 0 & 1 \\
      1 & 1 & 0 & 1 & 1 \\
      1 & 1 & 1 & 1 & 1 \\ \hline
    \end{tabular}
  \end{table}
\subsection{Boolean Algebra} \noindent
  \marginnote{3.6.5.1}There are several boolean identities that can be used to simplify a boolean expression, these are as follows: { \setlength\extrarowheight{5pt}
    \begin{longtable}{|l|l|l|}
      \hline
      \textbf{Identity Name} & \textbf{AND Form} & \textbf{OR Form} \\ \hline
      \textbf{Identity} & $A \bullet 1 = A$ & $A + 0 = A$  \\ \cline{2-3}
      \textbf{Null (or Dominance) Law} & $A \bullet 0 = 0$ & $A + 1 = 1$  \\ \cline{2-3}
      \textbf{Idempotence Law} & $A \bullet A = A$ & $A + A = A$  \\ \cline{2-3}
      \textbf{Inverse Law} & $A \bullet \overline{A} = 0$ & $A + \overline{A} = 1$  \\ \cline{2-3}
      \textbf{Commutative Law} & $A \bullet B = B \bullet A$ & $A + B = B + A$  \\ \cline{2-3}
      \textbf{Associative Law} & $(A \bullet B) \bullet C = A \bullet (B \bullet C)$ & $(A + B) + C = A + (B + C)$  \\ \cline{2-3}
      \textbf{Distributive Law} & $A + B \bullet C = (A+B)\bullet(A+C)$ & $A \bullet( B + C )= A \bullet B\ + A\bullet C$  \\ \cline{2-3}
      \textbf{Absorption Law} & $A \bullet (A+B) = A$ & $A + A\bullet B = A$  \\ \cline{2-3}
      \textbf{De Morgan's Law} & $\overline{A \bullet B} = \overline{A}+\overline{B}$ & $\overline{A + B} = \overline{A}\bullet\overline{B}$ \\ \cline{2-3}
      \textbf{Double Complement Law} & \multicolumn{2}{c|}{$\overline{\overline{A}}=A$}  \\ \hline
    \end{longtable} }
  \noindent
  Here's an example of how you could simplify a boolean expression:
  \begin{align*}
    (A \oplus B) \oplus B	& = (A \bullet \overline{B} + \overline{A} \bullet B) \oplus B \\
                & = (A \bullet \overline{B} + \overline{A} \bullet B) \bullet \overline{B} + \overline{(A \bullet \overline{B} + \overline{A} \bullet B)}\bullet B \\
                & = A \bullet \overline{B} \bullet \overline{B} + \overline{A} \bullet B \bullet \overline{B} + \overline{(A \bullet \overline{B} + \overline{A} \bullet B)}\bullet B \\
                & = A \bullet \overline{B} + \overline{(A \bullet \overline{B} + \overline{A} \bullet B)}\bullet B \\
                & = A \bullet \overline{B} + \overline{A \bullet \overline{B}} \bullet \overline{\overline{A} \bullet B}\bullet B \\
                & = A \bullet \overline{B} + (\overline{A} + B)\bullet(A + \overline{B})\bullet B \\
                & = A \bullet \overline{B} + (\overline{A}\bullet A + \overline{A}\bullet\overline{B} + A\bullet B + B \bullet \overline{B})\bullet B\\
                & = A \bullet \overline{B} + (\overline{A}\bullet\overline{B} + A\bullet B + B)\bullet B \\
                & = A \bullet \overline{B} + \overline{A} \bullet \overline{B} \bullet B + A \bullet B \bullet B \\
                & = A \bullet \overline{B} + A \bullet B \\
                & = A \bullet (\overline{B} + B)\\
    \therefore (A \oplus B) \oplus B	& = A
  \end{align*}
